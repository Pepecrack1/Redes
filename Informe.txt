Comprueba qu칠 ocurre si la funci칩n recvfrom() lee menos datos que los que envi칩 la funci칩n sendto(). 쮼s posible recuperar los datos restantes con una nueva llamada a recvfrom()? Describe las modificaciones introducidas en los c칩digos y el resultado obtenido.

Ponemos un tama침o de mensaje en el receptor mas peque침o que el tama침o de mensaje que env칤a el emisor.
Hacemos dos recv seguidos, para ver si el primero lee una parte del mensaje, y el segundo otra.
No sucede, el segundo recv no recibe nada a no ser que el servidor vuelva a enviar, y en ese caso, ambos reciben un el mensaje y guardan hasta donde cabe en su tama침o especificado, as칤 que NO es posible recuperar todo.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Modificar los programas para que, en vez de transmitir cadenas de texto, se transmita un array de n칰meros de tipo float. El n칰mero de datos enviados se debe especificar 칰nicamente en el programa que env칤a. Es decir, el programa que recibe debe ser capaz de recibir todos los datos enviados y determinar dicho n칰mero de datos. Describe las modificaciones introducidas en los c칩digos y el resultado obtenido.

Lo que hicimos, seg칰n entendimos, es en el emisor enviar primero un mensaje con el tama침o (en bytes) del array a recibir, que se enviar치 al receptor, y este reservar치 memoria para el array con ese tama침o.
Despu칠s, el emisor env칤a al receptor el array completo en un 칰nico mensaje, y el receptor lo recibe sin problemas en el espacio reservado que ten칤a.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Comprobaci칩n de que se pueden atender varios clientes simult치neamente. En el lazo del cliente, donde se van leyendo las l칤neas del archivo, introducir un sleep para que d칠 tiempo a lanzar un segundo cliente en otra terminal. Describe lo que ocurre.

Introducimos el sleep en el lazo de lectura del cliente, le ponemos sleep(2) por cada lectura, para asegurar que no termina antes de tiempo.
Ejecutamos entonces el servidor, y luego el primer cliente, que comienza a intercambiar datos con el servidor pero, antes de que termine, ejecutamos el segundo cliente, y observamos que este tambi칠n empieza a intercambiar datos con el servidor, altern치ndose con el otro. Esto sucede ya que UDP es un protocolo no orientado a conexi칩n, y entonces un servidor puede atender a varios clientes a la vez, ya que el servidor no establece conexi칩n, y por tanto no se cierra a otros clientes hasta que termine la conexi칩n, como sucede en TCP, sino que puede recibir mensajes de otros, atendi칠ndolos de forma independiente.

游봃游봃游봃游봃游봃游봃游봃游봃游봃游봃游봃游봃游봃游봃游봃游봃游봃游봃游봃游봃
